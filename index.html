<!doctype html>
<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

        <title>Babylon.js sample code</title>

        <!-- Babylon.js -->
        <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.6.2/dat.gui.min.js"></script>
        <script src="https://assets.babylonjs.com/generated/Assets.js"></script>
        <script src="https://cdn.babylonjs.com/recast.js"></script>
        <script src="https://cdn.babylonjs.com/ammo.js"></script>
        <script src="https://cdn.babylonjs.com/havok/HavokPhysics_umd.js"></script>
        <script src="https://cdn.babylonjs.com/cannon.js"></script>
        <script src="https://cdn.babylonjs.com/Oimo.js"></script>
        <script src="https://cdn.babylonjs.com/earcut.min.js"></script>
        <script src="https://cdn.babylonjs.com/babylon.js"></script>
        <script src="https://cdn.babylonjs.com/materialsLibrary/babylonjs.materials.min.js"></script>
        <script src="https://cdn.babylonjs.com/proceduralTexturesLibrary/babylonjs.proceduralTextures.min.js"></script>
        <script src="https://cdn.babylonjs.com/postProcessesLibrary/babylonjs.postProcess.min.js"></script>
        <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.js"></script>
        <script src="https://cdn.babylonjs.com/serializers/babylonjs.serializers.min.js"></script>
        <script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>
        <script src="https://cdn.babylonjs.com/addons/babylonjs.addons.min.js"></script>
        <script src="https://cdn.babylonjs.com/inspector/babylon.inspector.bundle.js"></script>

        <style>
            html,
            body {
                overflow: hidden;
                width: 100%;
                height: 100%;
                margin: 0;
                padding: 0;
            }

            #renderCanvas {
                width: 100%;
                height: 100%;
                touch-action: none;
            }

            #canvasZone {
                width: 100%;
                height: 100%;
            }
        </style>
    </head>
    <body>
        <div id="canvasZone"><canvas id="renderCanvas"></canvas></div>
        <script>
                    var canvas = document.getElementById("renderCanvas");

                    var startRenderLoop = function (engine, canvas) {
                        engine.runRenderLoop(function () {
                            if (sceneToRender && sceneToRender.activeCamera) {
                                sceneToRender.render();
                            }
                        });
                    }

                    var engine = null;
        var scene = null;
        var sceneToRender = null;
        var createDefaultEngine = function() { return new BABYLON.Engine(canvas, true, { preserveDrawingBuffer: true, stencil: true,  disableWebGL2Support: false}); };
        // pong.js - configurably holographic Pong with proper grid and scoreboard orientation

// ===== CONFIGURABLE CONSTANTS =====
const PADDLE_WIDTH           = 0.5;
const PADDLE_HEIGHT          = 3;
const PADDLE_DEPTH           = 1;
const PADDLE_OFFSET_X        = 7;

const FIELD_WIDTH            = 12;
const FIELD_HEIGHT           = 10;
const WALL_THICKNESS         = 1;

const BALL_DIAMETER          = 1;
const INITIAL_BALL_SPEED     = 0.08;
const BALL_SPEED_INCREMENT   = 1.05;

const PADDLE_MOVE_STEP       = 0.3;
const SCORE_BOUNDARY_X       = PADDLE_OFFSET_X + 1;

// ===== MAIN PLAYGROUND ENTRY POINT =====
var createScene = function () {
    const scene = new BABYLON.Scene(this._engine);

    // Fog for volumetric haze
    scene.fogMode    = BABYLON.Scene.FOGMODE_EXP;
    scene.fogColor   = new BABYLON.Color3(0.05, 0.1, 0.15);
    scene.fogDensity = 0.02;

    // Glow layer for subtle bloom
    const glow = new BABYLON.GlowLayer("glow", scene);
    glow.intensity = 0.3;

    // CAMERA
    const camera = new BABYLON.ArcRotateCamera(
      "cam", Math.PI/2, Math.PI/2,
      PADDLE_OFFSET_X * 4, BABYLON.Vector3.Zero(), scene
    );
    camera.inputs.removeByType("ArcRotateCameraKeyboardMoveInput");
    camera.attachControl(this._canvas, true);

    // LIGHT
    const light = new BABYLON.HemisphericLight(
      "light", new BABYLON.Vector3(0,1,0), scene
    );
    light.intensity = 0.7;

    // FIELD BOUNDS
    const halfW = FIELD_WIDTH / 2;
    const halfH = FIELD_HEIGHT / 2;
    const wallMat = new BABYLON.StandardMaterial("wallMat", scene);
    wallMat.alpha = 0;
    const top = BABYLON.MeshBuilder.CreateBox(
      "topWall", { width: FIELD_WIDTH, height: WALL_THICKNESS, depth: WALL_THICKNESS }, scene
    );
    top.position.y = halfH + WALL_THICKNESS/2;
    top.material   = wallMat;
    const bottom = top.clone("bottomWall");
    bottom.position.y = -halfH - WALL_THICKNESS/2;

    // BACK-WALL GRID: vertical ground with subdivisions
    const backWall = BABYLON.MeshBuilder.CreateGround("backWall", {
      width: FIELD_WIDTH,
      height: FIELD_HEIGHT,
      subdivisions: 20
    }, scene);
    backWall.rotation.x = Math.PI / 2;  // make vertical
    backWall.position.z = -PADDLE_OFFSET_X - 0.1;
    const gridMat = new BABYLON.StandardMaterial("gridMat", scene);
    gridMat.backFaceCulling = false;
    gridMat.emissiveColor   = new BABYLON.Color3(0.2, 0.6, 0.8);
    gridMat.alpha           = 0.5;
    gridMat.wireframe       = true;
    backWall.material       = gridMat;

    // Under-light to accentuate the grid
    const underLight = new BABYLON.PointLight(
      "under", new BABYLON.Vector3(0, -0.1, 0), scene
    );
    underLight.range     = FIELD_WIDTH;
    underLight.intensity = 0.5;
    underLight.diffuse   = new BABYLON.Color3(0.1, 0.5, 0.7);

    // PADDLES
    const paddleOpts = { width: PADDLE_WIDTH, height: PADDLE_HEIGHT, depth: PADDLE_DEPTH };
    const leftPaddle  = BABYLON.MeshBuilder.CreateBox("leftPaddle", paddleOpts, scene);
    leftPaddle.position.x = -PADDLE_OFFSET_X;
    const rightPaddle = leftPaddle.clone("rightPaddle");
    rightPaddle.position.x = PADDLE_OFFSET_X;

    // BALL
    const ball = BABYLON.MeshBuilder.CreateSphere(
      "ball", { diameter: BALL_DIAMETER }, scene
    );
    ball.position.set(0,0,0);

    // Holographic materials
    [leftPaddle, rightPaddle, ball].forEach(mesh => {
      const holoMat = new BABYLON.StandardMaterial("holo", scene);
      holoMat.alpha           = 0.3;
      holoMat.emissiveColor   = new BABYLON.Color3(0.1, 0.6, 0.9);
      holoMat.disableLighting = true;
      mesh.material           = holoMat;
    });

    // STATE
    let speed   = INITIAL_BALL_SPEED;
    let velocity = new BABYLON.Vector3(speed, speed, 0);
    let leftScore = 0, rightScore = 0;

    // INPUT
    const inputMap = {};
    scene.actionManager = new BABYLON.ActionManager(scene);
    scene.actionManager.registerAction(
      new BABYLON.ExecuteCodeAction(
        BABYLON.ActionManager.OnKeyDownTrigger,
        evt => inputMap[evt.sourceEvent.key] = true
      )
    );
    scene.actionManager.registerAction(
      new BABYLON.ExecuteCodeAction(
        BABYLON.ActionManager.OnKeyUpTrigger,
        evt => inputMap[evt.sourceEvent.key] = false
      )
    );

    // SCOREBOARD PLANE
    const scorePlane = BABYLON.MeshBuilder.CreatePlane("scorePlane", { width:4, height:1 }, scene);
    scorePlane.billboardMode = BABYLON.Mesh.BILLBOARDMODE_ALL;
    scorePlane.position.set(
      0,
      halfH + 1,
      -PADDLE_OFFSET_X * 0.5  // place slightly behind center toward camera
    );

    // DynamicTexture for text
    const dt = new BABYLON.DynamicTexture("dt", { width:512, height:128 }, scene, false);
    dt.hasAlpha = true;
    const scoreMat = new BABYLON.StandardMaterial("scoreMat", scene);
    scoreMat.diffuseTexture  = dt;
    scoreMat.emissiveColor   = new BABYLON.Color3(1,1,1);
    scoreMat.disableLighting = true;
    scorePlane.material      = scoreMat;

    function updateScoreTexture(text) {
      const ctx = dt.getContext();
      const { width, height } = dt.getSize();
      ctx.clearRect(0, 0, width, height);
      dt.drawText(text, width/2, height/2 + 20,
        "bold 72px Arial", "white", "transparent", true
      );
    }
    updateScoreTexture("0 : 0");

    // LOOP
    scene.onBeforeRenderObservable.add(() => {
      // Paddle movement
      if (inputMap["w"]      && rightPaddle.position.y < halfH - PADDLE_HEIGHT/2)  rightPaddle.position.y += PADDLE_MOVE_STEP;
      if (inputMap["s"]      && rightPaddle.position.y > -halfH + PADDLE_HEIGHT/2) rightPaddle.position.y -= PADDLE_MOVE_STEP;
      if (inputMap["ArrowUp"]   && leftPaddle.position.y  < halfH - PADDLE_HEIGHT/2) leftPaddle.position.y  += PADDLE_MOVE_STEP;
      if (inputMap["ArrowDown"] && leftPaddle.position.y  > -halfH + PADDLE_HEIGHT/2) leftPaddle.position.y  -= PADDLE_MOVE_STEP;

      // Ball trajectory
      const nextPos = ball.position.add(velocity);
      const maxY = halfH - BALL_DIAMETER/2;
      if (nextPos.y > maxY || nextPos.y < -maxY) {
        velocity.y *= -1;
        nextPos.y = BABYLON.Scalar.Clamp(nextPos.y, -maxY, maxY);
      }

      // Paddle collision
      [leftPaddle, rightPaddle].forEach(p => {
        const dx = nextPos.x - p.position.x;
        const dy = nextPos.y - p.position.y;
        const overlapX = (PADDLE_WIDTH/2 + BALL_DIAMETER/2) - Math.abs(dx);
        const overlapY = (PADDLE_HEIGHT/2 + BALL_DIAMETER/2) - Math.abs(dy);
        if (overlapX > 0 && overlapY > 0) {
          if (overlapX < overlapY) {
            velocity.x *= -BALL_SPEED_INCREMENT;
            nextPos.x = p.position.x + Math.sign(dx) * (PADDLE_WIDTH/2 + BALL_DIAMETER/2);
          } else {
            velocity.y *= -1;
            nextPos.y = p.position.y + Math.sign(dy) * (PADDLE_HEIGHT/2 + BALL_DIAMETER/2);
          }
        }
      });

      ball.position.copyFrom(nextPos);

      // Scoring
      if (ball.position.x > SCORE_BOUNDARY_X) {
        leftScore++;
        updateScoreTexture(`${leftScore} : ${rightScore}`);
        reset(-1);
      } else if (ball.position.x < -SCORE_BOUNDARY_X) {
        rightScore++;
        updateScoreTexture(`${leftScore} : ${rightScore}`);
        reset(1);
      }
    });

    function reset(dir) {
      ball.position.set(0,0,0);
      speed = INITIAL_BALL_SPEED;
      velocity = new BABYLON.Vector3(speed * dir, speed, 0);
    }

    return scene;
};

// Playground auto-calls createScene() and renders

                window.initFunction = async function() {
                    
                    
                    
                    var asyncEngineCreation = async function() {
                        try {
                        return createDefaultEngine();
                        } catch(e) {
                        console.log("the available createEngine function failed. Creating the default engine instead");
                        return createDefaultEngine();
                        }
                    }

                    window.engine = await asyncEngineCreation();
                    
                    const engineOptions = window.engine.getCreationOptions?.();
                    if (!engineOptions || engineOptions.audioEngine !== false) {
                        
                    }
        if (!engine) throw 'engine should not be null.';
        startRenderLoop(engine, canvas);
        window.scene = createScene();};
        initFunction().then(() => {sceneToRender = scene
                    });

                    // Resize
                    window.addEventListener("resize", function () {
                        engine.resize();
                    });
        </script>
    </body>
</html>
